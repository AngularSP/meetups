{"version":3,"file":"src_app_meetup_meetup_module_ts.js","mappings":"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,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IAEvB,OAAO,GAAG,CAAC;AACb,CAAC;;;;;;;;;;;;;;;ACfM;AACP,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkD;AACU;AACY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAW;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,+DAAc;AACzC,4BAA4B,kDAAW,YAAY,kDAAW;AAC9D,+BAA+B,kDAAW;AAC1C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8CAAO;AACrB,cAAc,8CAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAO;AACf;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yEAAmB;AAC3C;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC5GuC;AACvC;AACA;AACA,cAAc,eAAe,YAAY,4BAA4B,EAAE;AACvE;AACA;AACA,WAAW,8CAAO;AAClB;AACA;AACA;AACA,kBAAkB,KAAK,IAAI,MAAM,EAAE,+BAA+B;AAClE,KAAK;AACL;AACA;AACA;AACA,yBAAyB,UAAU,GAAG,OAAO;AAC7C;AACA;AACA;AACA,sCAAsC,UAAU,EAAE,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2CAAI;AAC1B;AACA,kCAAkC,sBAAsB,EAAE,UAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;ACzCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkD;AACA;AACoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAc;AAC/C;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,yDAAyD,gDAAS;AAClE;AACA,iBAAiB,gDAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAc;AACzC,4BAA4B,kDAAW,YAAY,kDAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,yBAAyB,8CAAO;AAChC;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;ACxEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkD;AACuB;AACzE;AACA;AACA,mEAAmE;AAC5D;AACP;AACA,2CAA2C;AAC3C,uCAAuC,QAAQ;AAC/C;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,mCAAmC,gDAAS;AAC5C;AACO;AACP,kCAAkC,iDAAU;AAC5C;AACA,wCAAwC,+DAAc;AACtD;AACA;AACA,mBAAmB,kDAAW,OAAO,kDAAW;AAChD;AACA,eAAe,kDAAW,YAAY,kDAAW;AACjD,KAAK;AACL,sEAAsE,QAAQ;AAC9E;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC;AACA;AACA,SAAS;AACT;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACiC;AAC8B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,cAAc;AACjF;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,YAAY,OAAO;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,aAAa,aAAa,MAAM,gBAAgB,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAO;AAC/B;AACA,yBAAyB;AACzB;AACA;AACA,4EAA4E,WAAW;AACvF;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,0BAA0B,4DAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAO;AAC3B,SAAS;AACT;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAc;AACjC,SAAS;AACT;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;ACpN6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,iBAAiB,mBAAmB;AACpC;AACA,cAAc,0DAAmB;AACjC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACnEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACwC;AACI;AACoB;AACD;AACgD;AAC/G,wCAAwC;AACxC,mCAAmC,mDAAY;AAC/C,qCAAqC,oDAAa;AAClD,aAAa;AACb;AACO,iCAAiC;AACxC;AACA,gBAAgB,gBAAgB;AAChC;AACA,kCAAkC,qDAAS;AAC3C,kCAAkC,6DAAa;AAC/C,kCAAkC,yDAAW;AAC7C,kCAAkC,6EAAqB;AACvD,kCAAkC,oDAAa;AAC/C,KAAK;AACL;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA,kBAAkB,8CAAW;AAC7B;AACA;AACA;AACA,gDAAgD,oDAAa;AAC7D,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO,uCAAuC;AAC9C;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO,iCAAiC;AACxC;AACA;AACA,KAAK;AACL;AACO,kCAAkC;AACzC;AACA;AACA,KAAK;AACL;AACO,kCAAkC;AACzC;AACA,4CAA4C,+CAAY;AACxD,KAAK;AACL;AACO,2CAA2C;AAClD;AACA,eAAe,6DAAa;AAC5B,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9GA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,mBAAmB,UAAU,SAAS,QAAQ;AAC9C;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sDAAsD;AACjE;AACA;AACA,mBAAmB,SAAS,EAAE,QAAQ;AACtC;AACA,CAAC;AACM;AACA;AACP;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,0CAA0C,mBAAmB;AAC7D,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB,KAAK;AACrE,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C,sCAAsC,OAAO;AAC7C,2CAA2C,OAAO,EAAE,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL","sources":["./src/app/meetup/banner/banner.component.ts","./src/app/meetup/banner/banner.component.html","./src/app/meetup/meetup-routing.module.ts","./src/app/meetup/meetup.component.ts","./src/app/meetup/meetup.component.html","./src/app/meetup/meetup.module.ts","./src/app/meetup/meetup.service.ts","./src/app/utils/slugify.ts","./node_modules/html-to-image/es/applyStyleWithOptions.js","./node_modules/html-to-image/es/cloneNode.js","./node_modules/html-to-image/es/clonePseudoElements.js","./node_modules/html-to-image/es/embedImages.js","./node_modules/html-to-image/es/embedResources.js","./node_modules/html-to-image/es/embedWebFonts.js","./node_modules/html-to-image/es/getBlobFromURL.js","./node_modules/html-to-image/es/index.js","./node_modules/html-to-image/es/util.js"],"sourcesContent":["import { Component, ElementRef, OnInit, ViewChild } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\nimport { toJpeg, toPng } from 'html-to-image';\nimport { Observable } from 'rxjs';\nimport { map, tap } from 'rxjs/operators';\nimport { MeetupService } from '../meetup.service';\nimport { slugfy } from './../../utils/slugify';\n\ntype ImageSize = 'Instagram' | 'Facebook' | 'Linkedin';\n@Component({\n  selector: 'app-banner',\n  templateUrl: './banner.component.html',\n  styleUrls: ['./banner.component.scss']\n})\nexport class BannerComponent implements OnInit {\n  public data$: Observable<any>;\n  public talkIdx = 0;\n  imageSize: ImageSize = 'Linkedin';\n  bannerName: string;\n\n  @ViewChild('banner') banner!: ElementRef;\n\n  constructor(\n    private meetupService: MeetupService,\n    private router: ActivatedRoute,\n  ) { }\n\n  ngOnInit(): void {\n    const meetupId = this.router.snapshot.params.id;\n    this.talkIdx = this.router.snapshot.params.talk - 1;\n\n    this.data$ = this.meetupService.getEvents().pipe(\n      map((data) => data.find(item => item.id === +meetupId)),\n      tap(item => {\n        this.bannerName = slugfy(item?.talks[this.talkIdx]?.title);\n      })\n    );\n  }\n\n  getBackGroundColor(data): string {\n    return `linear-gradient(145deg,${data.primaryColor},${data.secondaryColor})`;\n  }\n\n  downloadImage(type: 'png' | 'jpeg'): void {\n    switch (type) {\n      case 'png':\n        return this.savePng();\n      case 'jpeg':\n        return this.saveJpeg();\n    }\n  }\n\n  selectImageSize(size: ImageSize): void {\n    this.imageSize = size;\n  }\n\n  private savePng(): void {\n    toPng(this.banner.nativeElement)\n      .then((dataUrl) => {\n        const link = document.createElement('a');\n        link.download = `${this.bannerName}-${this.imageSize}.png`;\n        link.href = dataUrl;\n        link.click();\n      })\n      .catch((err) => {\n        console.log(err);\n      });\n  }\n\n  private saveJpeg(): void {\n    toJpeg(this.banner.nativeElement, { quality: 0.95 })\n      .then((dataUrl) => {\n        const link = document.createElement('a');\n        link.download = `${this.bannerName}-${this.imageSize}.jpeg`;\n        link.href = dataUrl;\n        link.click();\n      })\n      .catch((err) => {\n        console.log(err);\n      });\n  }\n}\n","<div class=\"container\">\n  <div class=\"column\">\n    <div\n      class=\"banner\"\n      [ngClass]=\"{\n        'linkedin-width': imageSize === 'Linkedin',\n        'instagram-width': imageSize === 'Instagram',\n        'facebook-width': imageSize === 'Facebook'\n      }\"\n      *ngIf=\"data$ | async as data\"\n      #banner\n    >\n      <header>\n        <div\n          [ngClass]=\"{\n            'linkedin-width': imageSize === 'Linkedin',\n            'instagram-width': imageSize === 'Instagram',\n            'facebook-width': imageSize === 'Facebook'\n          }\"\n          class=\"background\"\n          [style.background]=\"getBackGroundColor(data)\"\n        ></div>\n        <section class=\"intro\">\n          <div class=\"intro__logo\">\n            <img\n              src=\"assets/logo.svg\"\n              alt=\"AngularSP\"\n              width=\"300\"\n              height=\"300\"\n            />\n          </div>\n          <div class=\"intro__info\">\n            <h1>AngularSP #{{ data.id }}</h1>\n            <h2>{{ data.date }}</h2>\n            <h3>{{ data.title }}</h3>\n          </div>\n        </section>\n      </header>\n\n      <article>\n        <div class=\"content\">\n          <div class=\"content__photo\">\n            <img\n              src=\"assets/photos/{{ data.talks[talkIdx].photo }}\"\n              alt=\"spekar\"\n            />\n          </div>\n          <div class=\"content__info\">\n            <span class=\"info__talk\">{{ data.talks[talkIdx].subtitle }}</span>\n            <h1 class=\"info__title\">{{ data.talks[talkIdx].title }}</h1>\n            <p class=\"info__speaker\">\n              Por <strong>{{ data.talks[talkIdx].speaker }}</strong>\n            </p>\n            <p class=\"info__description\">\n              {{ data.talks[talkIdx].description }}\n            </p>\n          </div>\n        </div>\n      </article>\n    </div>\n  </div>\n  <div class=\"column actions\">\n    <section class=\"column actions\">\n      <span> Selecione o tamanho do Banner: </span>\n      <button (click)=\"selectImageSize('Instagram')\">Instagram</button>\n      <button (click)=\"selectImageSize('Linkedin')\">Linkedin</button>\n      <button (click)=\"selectImageSize('Facebook')\">Facebook</button>\n    </section>\n\n    <section class=\"column save-image\">\n      Salve a imagem:\n      <button (click)=\"downloadImage('png')\">Download PNG</button>\n      <button (click)=\"downloadImage('jpeg')\">Download JPEG</button>\n    </section>\n  </div>\n</div>\n","import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\nimport { BannerComponent } from './banner/banner.component';\nimport { MeetupComponent } from './meetup.component';\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: MeetupComponent,\n  },\n  {\n    path: ':id/banner/:talk',\n    component: BannerComponent,\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class MeetupRoutingModule { }\n","import { Component, OnInit } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nimport { MeetupService } from './meetup.service';\n\n@Component({\n  selector: 'app-meetup',\n  templateUrl: './meetup.component.html',\n  styleUrls: ['./meetup.component.css']\n})\nexport class MeetupComponent implements OnInit {\n  public events$: Observable<any>;\n\n  constructor(private meetupService: MeetupService) { }\n\n  ngOnInit(): void {\n    this.events$ = this.meetupService.getEvents();\n  }\n\n}\n","<div class=\"container\">\n  <h1>Meetups AngularSP</h1>\n  <ul>\n    <li *ngFor=\"let event of events$ | async\">\n      <strong>Meetup {{event?.id}} - {{event?.title}}</strong>\n      <ul>\n        <li *ngFor=\"let talk of event.talks; let i = index\">\n          <a [routerLink]=\"[event.id, 'banner', i + 1]\">Talk {{i + 1}}</a>\n        </li>\n      </ul>\n    </li>\n  </ul>\n</div>\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\n\nimport { BannerComponent } from './banner/banner.component';\nimport { MeetupRoutingModule } from './meetup-routing.module';\nimport { MeetupComponent } from './meetup.component';\n\n@NgModule({\n  declarations: [\n    MeetupComponent,\n    BannerComponent\n  ],\n  imports: [\n    CommonModule,\n    MeetupRoutingModule\n  ]\n})\nexport class MeetupModule { }\n","import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MeetupService {\n  constructor(private http: HttpClient) { }\n\n  getEvents(): Observable<any> {\n    return this.http.get('assets/events.json');\n  }\n}\n","export const slugfy = (str) => {\n  str = str.replace(/^\\s+|\\s+$/g, '');\n  str = str.toLowerCase();\n\n  let from = 'àáäâèéëêìíïîòóöôùúüûñç·/_,:;';\n  let to = 'aaaaeeeeiiiioooouuuunc------';\n  for (let i = 0, l = from.length; i < l; i++) {\n    str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));\n  }\n\n  str = str.replace(/[^a-z0-9 -]/g, '')\n    .replace(/\\s+/g, '-')\n    .replace(/-+/g, '-');\n\n  return str;\n}\n","export function applyStyleWithOptions(node, options) {\n    const { style } = node;\n    if (options.backgroundColor) {\n        style.backgroundColor = options.backgroundColor;\n    }\n    if (options.width) {\n        style.width = `${options.width}px`;\n    }\n    if (options.height) {\n        style.height = `${options.height}px`;\n    }\n    const manual = options.style;\n    if (manual != null) {\n        Object.keys(manual).forEach((key) => {\n            style[key] = manual[key];\n        });\n    }\n    return node;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { clonePseudoElements } from './clonePseudoElements';\nimport { createImage, getMimeType, makeDataUrl, toArray } from './util';\nfunction cloneCanvasElement(node) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const dataURL = node.toDataURL();\n        if (dataURL === 'data:,') {\n            return Promise.resolve(node.cloneNode(false));\n        }\n        return createImage(dataURL);\n    });\n}\nfunction cloneVideoElement(node, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return Promise.resolve(node.poster)\n            .then((url) => getBlobFromURL(url, options))\n            .then((data) => makeDataUrl(data.blob, getMimeType(node.poster) || data.contentType))\n            .then((dataURL) => createImage(dataURL));\n    });\n}\nfunction cloneSingleNode(node, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (node instanceof HTMLCanvasElement) {\n            return cloneCanvasElement(node);\n        }\n        if (node instanceof HTMLVideoElement && node.poster) {\n            return cloneVideoElement(node, options);\n        }\n        return Promise.resolve(node.cloneNode(false));\n    });\n}\nconst isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';\nfunction cloneChildren(nativeNode, clonedNode, options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const children = isSlotElement(nativeNode) && nativeNode.assignedNodes\n            ? toArray(nativeNode.assignedNodes())\n            : toArray(((_a = nativeNode.shadowRoot) !== null && _a !== void 0 ? _a : nativeNode).childNodes);\n        if (children.length === 0 || nativeNode instanceof HTMLVideoElement) {\n            return Promise.resolve(clonedNode);\n        }\n        return children\n            .reduce((deferred, child) => deferred\n            // eslint-disable-next-line no-use-before-define\n            .then(() => cloneNode(child, options))\n            .then((clonedChild) => {\n            // eslint-disable-next-line promise/always-return\n            if (clonedChild) {\n                clonedNode.appendChild(clonedChild);\n            }\n        }), Promise.resolve())\n            .then(() => clonedNode);\n    });\n}\nfunction cloneCSSStyle(nativeNode, clonedNode) {\n    const source = window.getComputedStyle(nativeNode);\n    const target = clonedNode.style;\n    if (!target) {\n        return;\n    }\n    if (source.cssText) {\n        target.cssText = source.cssText;\n    }\n    else {\n        toArray(source).forEach((name) => {\n            target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));\n        });\n    }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n    if (nativeNode instanceof HTMLTextAreaElement) {\n        clonedNode.innerHTML = nativeNode.value;\n    }\n    if (nativeNode instanceof HTMLInputElement) {\n        clonedNode.setAttribute('value', nativeNode.value);\n    }\n}\nfunction decorate(nativeNode, clonedNode) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!(clonedNode instanceof Element)) {\n            return Promise.resolve(clonedNode);\n        }\n        return Promise.resolve()\n            .then(() => cloneCSSStyle(nativeNode, clonedNode))\n            .then(() => clonePseudoElements(nativeNode, clonedNode))\n            .then(() => cloneInputValue(nativeNode, clonedNode))\n            .then(() => clonedNode);\n    });\n}\nexport function cloneNode(node, options, isRoot) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!isRoot && options.filter && !options.filter(node)) {\n            return Promise.resolve(null);\n        }\n        return Promise.resolve(node)\n            .then((clonedNode) => cloneSingleNode(clonedNode, options))\n            .then((clonedNode) => cloneChildren(node, clonedNode, options))\n            .then((clonedNode) => decorate(node, clonedNode));\n    });\n}\n","import { uuid, toArray } from './util';\nfunction formatCSSText(style) {\n    const content = style.getPropertyValue('content');\n    return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`;\n}\nfunction formatCSSProperties(style) {\n    return toArray(style)\n        .map((name) => {\n        const value = style.getPropertyValue(name);\n        const priority = style.getPropertyPriority(name);\n        return `${name}: ${value}${priority ? ' !important' : ''};`;\n    })\n        .join(' ');\n}\nfunction getPseudoElementStyle(className, pseudo, style) {\n    const selector = `.${className}:${pseudo}`;\n    const cssText = style.cssText\n        ? formatCSSText(style)\n        : formatCSSProperties(style);\n    return document.createTextNode(`${selector}{${cssText}}`);\n}\nfunction clonePseudoElement(nativeNode, clonedNode, pseudo) {\n    const style = window.getComputedStyle(nativeNode, pseudo);\n    const content = style.getPropertyValue('content');\n    if (content === '' || content === 'none') {\n        return;\n    }\n    const className = uuid();\n    try {\n        clonedNode.className = `${clonedNode.className} ${className}`;\n    }\n    catch (err) {\n        return;\n    }\n    const styleElement = document.createElement('style');\n    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));\n    clonedNode.appendChild(styleElement);\n}\nexport function clonePseudoElements(nativeNode, clonedNode) {\n    clonePseudoElement(nativeNode, clonedNode, ':before');\n    clonePseudoElement(nativeNode, clonedNode, ':after');\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { embedResources } from './embedResources';\nimport { getMimeType, isDataUrl, makeDataUrl, toArray } from './util';\nfunction embedBackground(clonedNode, options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const background = (_a = clonedNode.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue('background');\n        if (!background) {\n            return Promise.resolve(clonedNode);\n        }\n        return Promise.resolve(background)\n            .then((cssString) => embedResources(cssString, null, options))\n            .then((cssString) => {\n            clonedNode.style.setProperty('background', cssString, clonedNode.style.getPropertyPriority('background'));\n            return clonedNode;\n        });\n    });\n}\nfunction embedImageNode(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!(clonedNode instanceof HTMLImageElement && !isDataUrl(clonedNode.src)) &&\n            !(clonedNode instanceof SVGImageElement &&\n                !isDataUrl(clonedNode.href.baseVal))) {\n            return Promise.resolve(clonedNode);\n        }\n        const src = clonedNode instanceof HTMLImageElement\n            ? clonedNode.src\n            : clonedNode.href.baseVal;\n        return Promise.resolve(src)\n            .then((url) => getBlobFromURL(url, options))\n            .then((data) => makeDataUrl(data.blob, getMimeType(src) || data.contentType))\n            .then((dataURL) => new Promise((resolve, reject) => {\n            clonedNode.onload = resolve;\n            clonedNode.onerror = reject;\n            if (clonedNode instanceof HTMLImageElement) {\n                clonedNode.srcset = '';\n                clonedNode.src = dataURL;\n            }\n            else {\n                clonedNode.href.baseVal = dataURL;\n            }\n        }))\n            .then(() => clonedNode, () => clonedNode);\n    });\n}\nfunction embedChildren(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const children = toArray(clonedNode.childNodes);\n        // eslint-disable-next-line no-use-before-define\n        const deferreds = children.map((child) => embedImages(child, options));\n        return Promise.all(deferreds).then(() => clonedNode);\n    });\n}\nexport function embedImages(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!(clonedNode instanceof Element)) {\n            return Promise.resolve(clonedNode);\n        }\n        return Promise.resolve(clonedNode)\n            .then((node) => embedBackground(node, options))\n            .then((node) => embedImageNode(node, options))\n            .then((node) => embedChildren(node, options));\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { getMimeType, isDataUrl, makeDataUrl, resolveUrl } from './util';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"'])([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nexport function toRegex(url) {\n    // eslint-disable-next-line no-useless-escape\n    const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n    return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g');\n}\nexport function parseURLs(cssText) {\n    const result = [];\n    cssText.replace(URL_REGEX, (raw, quotation, url) => {\n        result.push(url);\n        return raw;\n    });\n    return result.filter((url) => !isDataUrl(url));\n}\nexport function embed(cssText, resourceURL, baseURL, options, get) {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n    return Promise.resolve(resolvedURL)\n        .then((url) => get ? get(url) : getBlobFromURL(url, options))\n        .then((data) => {\n        if (typeof data === 'string') {\n            return makeDataUrl(data, getMimeType(resourceURL));\n        }\n        return makeDataUrl(data.blob, getMimeType(resourceURL) || data.contentType);\n    })\n        .then((dataURL) => cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`))\n        .then((content) => content, () => resolvedURL);\n}\nfunction filterPreferredFontFormat(str, { preferredFontFormat }) {\n    return !preferredFontFormat\n        ? str\n        : str.replace(FONT_SRC_REGEX, (match) => {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n                if (!format) {\n                    return '';\n                }\n                if (format === preferredFontFormat) {\n                    return `src: ${src};`;\n                }\n            }\n        });\n}\nexport function shouldEmbed(url) {\n    return url.search(URL_REGEX) !== -1;\n}\nexport function embedResources(cssText, baseUrl, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!shouldEmbed(cssText)) {\n            return Promise.resolve(cssText);\n        }\n        const filteredCSSText = filterPreferredFontFormat(cssText, options);\n        return Promise.resolve(filteredCSSText)\n            .then(parseURLs)\n            .then((urls) => urls.reduce((deferred, url) => \n        // eslint-disable-next-line promise/no-nesting\n        deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText)));\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { toArray } from './util';\nimport { shouldEmbed, embedResources } from './embedResources';\nconst cssFetchCache = {};\nfunction fetchCSS(url) {\n    const cache = cssFetchCache[url];\n    if (cache != null) {\n        return cache;\n    }\n    const deferred = window.fetch(url).then((res) => ({\n        url,\n        cssText: res.text(),\n    }));\n    cssFetchCache[url] = deferred;\n    return deferred;\n}\nfunction embedFonts(meta) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return meta.cssText.then((raw) => {\n            let cssText = raw;\n            const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n            const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n            const loadFonts = fontLocs.map((location) => {\n                let url = location.replace(regexUrl, '$1');\n                if (!url.startsWith('https://')) {\n                    url = new URL(url, meta.url).href;\n                }\n                // eslint-disable-next-line promise/no-nesting\n                return window\n                    .fetch(url)\n                    .then((res) => res.blob())\n                    .then((blob) => new Promise((resolve, reject) => {\n                    const reader = new FileReader();\n                    reader.onloadend = () => {\n                        // Side Effect\n                        cssText = cssText.replace(location, `url(${reader.result})`);\n                        resolve([location, reader.result]);\n                    };\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }));\n            });\n            // eslint-disable-next-line promise/no-nesting\n            return Promise.all(loadFonts).then(() => cssText);\n        });\n    });\n}\nfunction parseCSS(source) {\n    if (source == null) {\n        return [];\n    }\n    const result = [];\n    const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    // strip out comments\n    let cssText = source.replace(commentsRegex, '');\n    const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const matches = keyframesRegex.exec(cssText);\n        if (matches === null) {\n            break;\n        }\n        result.push(matches[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, '');\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // to match css & media queries together\n    const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n        '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})';\n    // unified regex\n    const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        let matches = importRegex.exec(cssText);\n        if (matches === null) {\n            matches = unifiedRegex.exec(cssText);\n            if (matches === null) {\n                break;\n            }\n            else {\n                importRegex.lastIndex = unifiedRegex.lastIndex;\n            }\n        }\n        else {\n            unifiedRegex.lastIndex = importRegex.lastIndex;\n        }\n        result.push(matches[0]);\n    }\n    return result;\n}\nfunction getCSSRules(styleSheets) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const ret = [];\n        const deferreds = [];\n        // First loop inlines imports\n        styleSheets.forEach((sheet) => {\n            if ('cssRules' in sheet) {\n                try {\n                    toArray(sheet.cssRules).forEach((item, index) => {\n                        if (item.type === CSSRule.IMPORT_RULE) {\n                            let importIndex = index + 1;\n                            const url = item.href;\n                            const deferred = fetchCSS(url)\n                                .then((metadata) => (metadata ? embedFonts(metadata) : ''))\n                                .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                                try {\n                                    sheet.insertRule(rule, rule.startsWith('@import')\n                                        ? (importIndex += 1)\n                                        : sheet.cssRules.length);\n                                }\n                                catch (error) {\n                                    console.error('Error inserting rule from remote css', {\n                                        rule,\n                                        error,\n                                    });\n                                }\n                            }))\n                                .catch((e) => {\n                                console.error('Error loading remote css', e.toString());\n                            });\n                            deferreds.push(deferred);\n                        }\n                    });\n                }\n                catch (e) {\n                    const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];\n                    if (sheet.href != null) {\n                        deferreds.push(fetchCSS(sheet.href)\n                            .then((metadata) => (metadata ? embedFonts(metadata) : ''))\n                            .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                            inline.insertRule(rule, sheet.cssRules.length);\n                        }))\n                            .catch((err) => {\n                            console.error('Error loading remote stylesheet', err.toString());\n                        }));\n                    }\n                    console.error('Error inlining remote css file', e.toString());\n                }\n            }\n        });\n        return Promise.all(deferreds).then(() => {\n            // Second loop parses rules\n            styleSheets.forEach((sheet) => {\n                if ('cssRules' in sheet) {\n                    try {\n                        toArray(sheet.cssRules).forEach((item) => {\n                            ret.push(item);\n                        });\n                    }\n                    catch (e) {\n                        console.error(`Error while reading CSS rules from ${sheet.href}`, e.toString());\n                    }\n                }\n            });\n            return ret;\n        });\n    });\n}\nfunction getWebFontRules(cssRules) {\n    return cssRules\n        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nfunction parseWebFontRules(node) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            if (node.ownerDocument == null) {\n                reject(new Error('Provided element is not within a Document'));\n            }\n            resolve(toArray(node.ownerDocument.styleSheets));\n        })\n            .then((styleSheets) => getCSSRules(styleSheets))\n            .then(getWebFontRules);\n    });\n}\nexport function getWebFontCSS(node, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return parseWebFontRules(node)\n            .then((rules) => Promise.all(rules.map((rule) => {\n            const baseUrl = rule.parentStyleSheet\n                ? rule.parentStyleSheet.href\n                : null;\n            return embedResources(rule.cssText, baseUrl, options);\n        })))\n            .then((cssTexts) => cssTexts.join('\\n'));\n    });\n}\nexport function embedWebFonts(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return (options.fontEmbedCSS != null\n            ? Promise.resolve(options.fontEmbedCSS)\n            : getWebFontCSS(clonedNode, options)).then((cssText) => {\n            const styleNode = document.createElement('style');\n            const sytleContent = document.createTextNode(cssText);\n            styleNode.appendChild(sytleContent);\n            if (clonedNode.firstChild) {\n                clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n            }\n            else {\n                clonedNode.appendChild(styleNode);\n            }\n            return clonedNode;\n        });\n    });\n}\n","import { parseDataUrlContent } from './util';\nconst cache = {};\nfunction getCacheKey(url) {\n    let key = url.replace(/\\?.*/, '');\n    // font resourse\n    if (/ttf|otf|eot|woff2?/i.test(key)) {\n        key = key.replace(/.*\\//, '');\n    }\n    return key;\n}\nexport function getBlobFromURL(url, options) {\n    const cacheKey = getCacheKey(url);\n    if (cache[cacheKey] != null) {\n        return cache[cacheKey];\n    }\n    // cache bypass so we dont have CORS issues with cached images\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) {\n        // eslint-disable-next-line no-param-reassign\n        url += (/\\?/.test(url) ? '&' : '?') + new Date().getTime();\n    }\n    const failed = (reason) => {\n        let placeholder = '';\n        if (options.imagePlaceholder) {\n            const parts = options.imagePlaceholder.split(/,/);\n            if (parts && parts[1]) {\n                placeholder = parts[1];\n            }\n        }\n        let msg = `Failed to fetch resource: ${url}`;\n        if (reason) {\n            msg = typeof reason === 'string' ? reason : reason.message;\n        }\n        if (msg) {\n            console.error(msg);\n        }\n        return {\n            blob: placeholder,\n            contentType: '',\n        };\n    };\n    const deferred = window\n        .fetch(url)\n        .then((res) => \n    // eslint-disable-next-line promise/no-nesting\n    res.blob().then((blob) => ({\n        blob,\n        contentType: res.headers.get('Content-Type') || '',\n    })))\n        .then(({ blob, contentType }) => new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => resolve({\n            contentType,\n            blob: reader.result,\n        });\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    }))\n        .then(({ blob, contentType }) => ({\n        contentType,\n        blob: parseDataUrlContent(blob),\n    }))\n        // on failed\n        .catch(failed);\n    // cache result\n    cache[cacheKey] = deferred;\n    return deferred;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { cloneNode } from './cloneNode';\nimport { embedImages } from './embedImages';\nimport { applyStyleWithOptions } from './applyStyleWithOptions';\nimport { embedWebFonts, getWebFontCSS } from './embedWebFonts';\nimport { getNodeWidth, getNodeHeight, getPixelRatio, createImage, canvasToBlob, nodeToDataURL, } from './util';\nfunction getImageSize(node, options = {}) {\n    const width = options.width || getNodeWidth(node);\n    const height = options.height || getNodeHeight(node);\n    return { width, height };\n}\nexport function toSvg(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { width, height } = getImageSize(node, options);\n        return Promise.resolve(node)\n            .then((nativeNode) => cloneNode(nativeNode, options, true))\n            .then((clonedNode) => embedWebFonts(clonedNode, options))\n            .then((clonedNode) => embedImages(clonedNode, options))\n            .then((clonedNode) => applyStyleWithOptions(clonedNode, options))\n            .then((clonedNode) => nodeToDataURL(clonedNode, width, height));\n    });\n}\nconst dimensionCanvasLimit = 16384; // as per https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nfunction checkCanvasDimensions(canvas) {\n    if (canvas.width > dimensionCanvasLimit ||\n        canvas.height > dimensionCanvasLimit) {\n        if (canvas.width > dimensionCanvasLimit &&\n            canvas.height > dimensionCanvasLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= dimensionCanvasLimit / canvas.width;\n                canvas.width = dimensionCanvasLimit;\n            }\n            else {\n                canvas.width *= dimensionCanvasLimit / canvas.height;\n                canvas.height = dimensionCanvasLimit;\n            }\n        }\n        else if (canvas.width > dimensionCanvasLimit) {\n            canvas.height *= dimensionCanvasLimit / canvas.width;\n            canvas.width = dimensionCanvasLimit;\n        }\n        else {\n            canvas.width *= dimensionCanvasLimit / canvas.height;\n            canvas.height = dimensionCanvasLimit;\n        }\n    }\n}\nexport function toCanvas(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toSvg(node, options)\n            .then(createImage)\n            .then((img) => {\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            const ratio = options.pixelRatio || getPixelRatio();\n            const { width, height } = getImageSize(node, options);\n            const canvasWidth = options.canvasWidth || width;\n            const canvasHeight = options.canvasHeight || height;\n            canvas.width = canvasWidth * ratio;\n            canvas.height = canvasHeight * ratio;\n            if (!options.skipAutoScale) {\n                checkCanvasDimensions(canvas);\n            }\n            canvas.style.width = `${canvasWidth}`;\n            canvas.style.height = `${canvasHeight}`;\n            if (options.backgroundColor) {\n                context.fillStyle = options.backgroundColor;\n                context.fillRect(0, 0, canvas.width, canvas.height);\n            }\n            context.drawImage(img, 0, 0, canvas.width, canvas.height);\n            return canvas;\n        });\n    });\n}\nexport function toPixelData(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { width, height } = getImageSize(node, options);\n        return toCanvas(node, options).then((canvas) => {\n            const ctx = canvas.getContext('2d');\n            return ctx.getImageData(0, 0, width, height).data;\n        });\n    });\n}\nexport function toPng(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toCanvas(node, options).then((canvas) => canvas.toDataURL());\n    });\n}\nexport function toJpeg(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toCanvas(node, options).then((canvas) => canvas.toDataURL('image/jpeg', options.quality || 1));\n    });\n}\nexport function toBlob(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return toCanvas(node, options).then(canvasToBlob);\n    });\n}\nexport function getFontEmbedCSS(node, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return getWebFontCSS(node, options);\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst WOFF = 'application/font-woff';\nconst JPEG = 'image/jpeg';\nconst mimes = {\n    woff: WOFF,\n    woff2: WOFF,\n    ttf: 'application/font-truetype',\n    eot: 'application/vnd.ms-fontobject',\n    png: 'image/png',\n    jpg: JPEG,\n    jpeg: JPEG,\n    gif: 'image/gif',\n    tiff: 'image/tiff',\n    svg: 'image/svg+xml',\n};\nexport function getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : '';\n}\nexport function getMimeType(url) {\n    const extension = getExtension(url).toLowerCase();\n    return mimes[extension] || '';\n}\nexport function resolveUrl(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) {\n        return url;\n    }\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) {\n        return window.location.protocol + url;\n    }\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) {\n        return url;\n    }\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement('base');\n    const a = doc.createElement('a');\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) {\n        base.href = baseUrl;\n    }\n    a.href = url;\n    return a.href;\n}\nexport function isDataUrl(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nexport function makeDataUrl(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nexport function parseDataUrlContent(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nexport const uuid = (function uuid() {\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = () => \n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * Math.pow(36, 4)) << 0).toString(36)}`.slice(-4);\n    return () => {\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nexport const delay = (ms) => (args) => new Promise((resolve) => setTimeout(() => resolve(args), ms));\nexport function toArray(arrayLike) {\n    const arr = [];\n    for (let i = 0, l = arrayLike.length; i < l; i += 1) {\n        arr.push(arrayLike[i]);\n    }\n    return arr;\n}\nfunction px(node, styleProperty) {\n    const val = window.getComputedStyle(node).getPropertyValue(styleProperty);\n    return parseFloat(val.replace('px', ''));\n}\nexport function getNodeWidth(node) {\n    const leftBorder = px(node, 'border-left-width');\n    const rightBorder = px(node, 'border-right-width');\n    return node.clientWidth + leftBorder + rightBorder;\n}\nexport function getNodeHeight(node) {\n    const topBorder = px(node, 'border-top-width');\n    const bottomBorder = px(node, 'border-bottom-width');\n    return node.clientHeight + topBorder + bottomBorder;\n}\nexport function getPixelRatio() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = process;\n    }\n    catch (e) {\n        // pass\n    }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env\n        ? FINAL_PROCESS.env.devicePixelRatio\n        : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (Number.isNaN(ratio)) {\n            ratio = 1;\n        }\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\nexport function canvasToBlob(canvas) {\n    if (canvas.toBlob) {\n        return new Promise((resolve) => canvas.toBlob(resolve));\n    }\n    return new Promise((resolve) => {\n        const binaryString = window.atob(canvas.toDataURL().split(',')[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for (let i = 0; i < len; i += 1) {\n            binaryArray[i] = binaryString.charCodeAt(i);\n        }\n        resolve(new Blob([binaryArray], { type: 'image/png' }));\n    });\n}\nexport function createImage(url) {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.onload = () => resolve(img);\n        img.onerror = reject;\n        img.crossOrigin = 'anonymous';\n        img.decoding = 'sync';\n        img.src = url;\n    });\n}\nexport function svgToDataURL(svg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return Promise.resolve()\n            .then(() => new XMLSerializer().serializeToString(svg))\n            .then(encodeURIComponent)\n            .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);\n    });\n}\nexport function nodeToDataURL(node, width, height) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const xmlns = 'http://www.w3.org/2000/svg';\n        const svg = document.createElementNS(xmlns, 'svg');\n        const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n        svg.setAttribute('width', `${width}`);\n        svg.setAttribute('height', `${height}`);\n        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n        foreignObject.setAttribute('width', '100%');\n        foreignObject.setAttribute('height', '100%');\n        foreignObject.setAttribute('x', '0');\n        foreignObject.setAttribute('y', '0');\n        foreignObject.setAttribute('externalResourcesRequired', 'true');\n        svg.appendChild(foreignObject);\n        foreignObject.appendChild(node);\n        return svgToDataURL(svg);\n    });\n}\n"],"names":[],"sourceRoot":"webpack:///"}